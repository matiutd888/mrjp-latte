-- File generated by the BNF Converter (bnfc 2.9.4).

-- | Program to test parser.
module Main where

import Control.Monad
import Control.Monad.Except
import Grammar.AbsLatte (Program)
import Grammar.LexLatte (Token, mkPosToken)
import Grammar.ParLatte (myLexer, pProgram)
import Grammar.PrintLatte (Print, printTree)
import Grammar.SkelLatte ()
import qualified SemanticAnalysis as SA
import System.Environment (getArgs)
import System.Exit
import System.Exit (exitFailure)
import System.FilePath
import System.IO (hPutStrLn, stderr)
import System.Process
import Utils
import Prelude
  ( Either (..),
    FilePath,
    IO,
    Int,
    Show,
    String,
    concat,
    getContents,
    mapM_,
    putStrLn,
    readFile,
    show,
    unlines,
    ($),
    (++),
    (.),
    (==),
    (>),
    (>>),
    (>>=),
  )

type ParseFun a = [Token] -> Either String a

type Verbosity = Int

putStrV :: Verbosity -> String -> IO ()
putStrV v s = when (v > 1) $ putStrLn s

getOutputLLFileFromInputFilePath :: FilePath -> FilePath
getOutputLLFileFromInputFilePath filePath = dropExtension filePath <.> "output"

runFile :: Verbosity -> ParseFun Program -> FilePath -> IO ()
runFile v p f = do
  putStrLn f
  validateFilePath f
  programStr <- readFile f
  -- let outputLLFilePath = getOutputLLFileFromInputFilePath f
  llvmProgramStr <- run v p programStr
  return ()

-- writeStringToFile outputLLFilePath llvmProgramStr
-- createLLVMBitcode outputLLFilePath

createLLVMBitcode :: FilePath -> IO ()
createLLVMBitcode llFilePath = do
  let outputFile = dropExtension llFilePath <.> "bc"
  let llvmAsCommand = "llvm-as -o " ++ outputFile ++ " " ++ llFilePath
  (_, _, _, processHandle) <- createProcess (shell llvmAsCommand)
  exitCode <- waitForProcess processHandle
  case exitCode of
    ExitSuccess -> putStrLn "LLVM bitcode file generated successfully"
    ExitFailure _ -> hPutStrLn stderr "llvm-as process encountered an error." >> exitFailure

run :: Verbosity -> ParseFun Program -> String -> IO String
run v p s =
  case p ts of
    Left err -> do
      putStrLn "\nParse              Failed...\n"
      putStrV v "Tokens:"
      mapM_ (putStrV v . showPosToken . mkPosToken) ts
      putStrLn err
      exitFailure
    Right tree -> do
      putStrLn "\nParse Successful!"
      showTree v tree
      putStrLn "\n"
      getLLFileContent tree
  where
    ts = myLexer s
    showPosToken ((l, c), t) = concat [show l, ":", show c, "\t", show t]
    getLLFileContent prog = do
      -- semAnalysisResult <- SA.semanticAnalysis prog
      -- case semAnalysisResult of
      --   Left m -> hPutStrLn stderr m >> exitFailure
      --   Right _ -> do

      -- llFileContent <- runExceptT $ getLLFile prog
      -- case llFileContent of
      --   Left m -> hPutStrLn stderr m >> exitFailure
      --   Right m -> putStrLn m >> return m
      return "backend not implemented yet"

showTree :: (Show a, Print a) => Int -> a -> IO ()
showTree v tree = do
  putStrV v $ "\n[Abstract Syntax]\n\n" ++ show tree
  putStrV v $ "\n[Linearized tree]\n\n" ++ printTree tree

usage :: IO ()
usage = do
  putStrLn $
    unlines
      [ "usage: Call with one of the following arguments:",
        "  --help          Display this help message.",
        "  <file>          Run Latte jvm compiler."
      ]

main :: IO ()
main = do
  args <- getArgs
  case args of
    ["--help"] -> usage
    [fs] -> runFile 2 pProgram fs >> return ()
    _ -> hPutStrLn stderr "Wrong program arguments (see --help)" >> exitFailure
